/******************************************************************* 
 * Header file generated by Protoc for Embedded C.                 *
 * Version 1.0M4 (2013-03-31)                                      *
 *                                                                 *
 * Copyright (c) 2009-2013                                         *
 * Technische Universitaet Muenchen                                *
 * http://www4.in.tum.de/                                          *
 *                                                                 *
 * Source : Message.proto
 *                                                                 *
 * Do not edit.                                                    *
 *******************************************************************/

#ifndef _Message_H
#define _Message_H

#ifdef __cplusplus
  extern "C" {
#endif

#define MAX_REPEATED_LENGTH 100
#define MAX_STRING_LENGTH 21

/*******************************************************************
 * General functions
 *******************************************************************/

/*
 * returns the size of a length delimited message which also 
 * contains the first bytes for the length encoding.
 */
unsigned long Message_get_delimited_size(void *_buffer, int offset);

/*
 * Tests whether a message can be completely read from the given buffer at
 * the offset. The bytes [offset..offset+length-1] are interpreted.
 *
 * Returns 1 (true) if buffer[offset..offset+length-1] contains a complete
 * message or 0 (false) otherwise.
 */
int Message_can_read_delimited_from(void *_buffer, int offset, unsigned int length);


/*******************************************************************
 * Enumeration: Message.proto, line 5
 *******************************************************************/
enum security_bill_t {
    BUY_IN_LIMIT_PRICE = 0,
    SELL_OUT_LIMIT_PRICE = 1,
    BUY_IN_MARKET_PRICE = 2,
    SELL_OUT_MARKET_PRICE = 3,
    BUY_WITHDRAW = 4,
    SELL_WITHDRAW = 5,
    ACCOUNT_CHARGE = 6,
    ACCOUNT_WITHDRAW = 7,
    CONTRACT_NOTE = 8
};


/*******************************************************************
 * Enumeration: Message.proto, line 17
 *******************************************************************/
enum bill_status_t {
    STATUS_NEW = 0,
    STATUS_PROCESSED = 1,
    STATUS_ACCEPTED = 2,
    STATUS_REJECTED = 3,
    STATUS_FINISHED = 4,
    STATUS_INVALID = 5
};


/*******************************************************************
 * Enumeration: Message.proto, line 26
 *******************************************************************/
enum message_type_t {
    UNKOWN_MESSAGE = 0,
    SECURITY_QUOTE = 1,
    WITHDRAW_QUOTE = 2,
    CONTRACT_NOTE = 3,
    ACCOUNT_EXCHANGE_NOTE = 4
};



/*******************************************************************
 * Message: Message.proto, line 35
 *******************************************************************/

/* Maximum size of a serialized SecurityQuote-message, useful for buffer allocation. */
#define MAX_SecurityQuote_SIZE 82

/* Structure that holds a deserialized SecurityQuote-message. */
struct SecurityQuote {
    enum message_type_t msg_type;
    enum security_bill_t billType;
    unsigned long billId;
    unsigned long occurTime;
    enum bill_status_t status;
    unsigned long long code;
    unsigned long price;
    unsigned long quality;
    unsigned long guaranty;
    int _client_len;
    char client[MAX_STRING_LENGTH];
};

/*
 * Serialize a Person-message into the given buffer at offset and return
 * new offset for optional next message.
 */
int SecurityQuote_write_delimited_to(struct SecurityQuote *_SecurityQuote, void *_buffer, int offset);

/*
 * Serialize a Person-message together with its tag into the given buffer 
 * at offset and return new offset for optional next message.
 * Is useful if a Person-message is embedded in another message.
 */
int SecurityQuote_write_with_tag(struct SecurityQuote *_SecurityQuote, void *_buffer, int offset, int tag);

/*
 * Deserialize a Person-message from the given buffer at offset and return
 * new offset for optional next message.
 *
 * Note: All fields in _Person will be reset to 0 before _buffer is interpreted.
 */
int SecurityQuote_read_delimited_from(void *_buffer, struct SecurityQuote *_SecurityQuote, int offset);


/*******************************************************************
 * Message: Message.proto, line 49
 *******************************************************************/

/* Maximum size of a serialized WithdrawQuote-message, useful for buffer allocation. */
#define MAX_WithdrawQuote_SIZE 68

/* Structure that holds a deserialized WithdrawQuote-message. */
struct WithdrawQuote {
    enum message_type_t msg_type;
    enum security_bill_t billType;
    unsigned long billId;
    unsigned long occurTime;
    enum bill_status_t status;
    unsigned long long code;
    unsigned long refBillId;
    int _client_len;
    char client[MAX_STRING_LENGTH];
};

/*
 * Serialize a Person-message into the given buffer at offset and return
 * new offset for optional next message.
 */
int WithdrawQuote_write_delimited_to(struct WithdrawQuote *_WithdrawQuote, void *_buffer, int offset);

/*
 * Serialize a Person-message together with its tag into the given buffer 
 * at offset and return new offset for optional next message.
 * Is useful if a Person-message is embedded in another message.
 */
int WithdrawQuote_write_with_tag(struct WithdrawQuote *_WithdrawQuote, void *_buffer, int offset, int tag);

/*
 * Deserialize a Person-message from the given buffer at offset and return
 * new offset for optional next message.
 *
 * Note: All fields in _Person will be reset to 0 before _buffer is interpreted.
 */
int WithdrawQuote_read_delimited_from(void *_buffer, struct WithdrawQuote *_WithdrawQuote, int offset);


/*******************************************************************
 * Message: Message.proto, line 61
 *******************************************************************/

/* Maximum size of a serialized ContractNote-message, useful for buffer allocation. */
#define MAX_ContractNote_SIZE 113

/* Structure that holds a deserialized ContractNote-message. */
struct ContractNote {
    enum message_type_t msg_type;
    enum security_bill_t billType;
    unsigned long billId;
    unsigned long occurTime;
    enum bill_status_t status;
    unsigned long long code;
    unsigned long price;
    unsigned long quality;
    unsigned long sourceBillId;
    unsigned long peerBillId;
    int _buyer_len;
    char buyer[MAX_STRING_LENGTH];
    int _seller_len;
    char seller[MAX_STRING_LENGTH];
};

/*
 * Serialize a Person-message into the given buffer at offset and return
 * new offset for optional next message.
 */
int ContractNote_write_delimited_to(struct ContractNote *_ContractNote, void *_buffer, int offset);

/*
 * Serialize a Person-message together with its tag into the given buffer 
 * at offset and return new offset for optional next message.
 * Is useful if a Person-message is embedded in another message.
 */
int ContractNote_write_with_tag(struct ContractNote *_ContractNote, void *_buffer, int offset, int tag);

/*
 * Deserialize a Person-message from the given buffer at offset and return
 * new offset for optional next message.
 *
 * Note: All fields in _Person will be reset to 0 before _buffer is interpreted.
 */
int ContractNote_read_delimited_from(void *_buffer, struct ContractNote *_ContractNote, int offset);


/*******************************************************************
 * Message: Message.proto, line 78
 *******************************************************************/

/* Maximum size of a serialized AccountExchangeNote-message, useful for buffer allocation. */
#define MAX_AccountExchangeNote_SIZE 68

/* Structure that holds a deserialized AccountExchangeNote-message. */
struct AccountExchangeNote {
    enum message_type_t msg_type;
    enum security_bill_t billType;
    unsigned long billId;
    unsigned long occurTime;
    enum bill_status_t status;
    unsigned long long code;
    unsigned long quality;
    int _client_len;
    char client[MAX_STRING_LENGTH];
};

/*
 * Serialize a Person-message into the given buffer at offset and return
 * new offset for optional next message.
 */
int AccountExchangeNote_write_delimited_to(struct AccountExchangeNote *_AccountExchangeNote, void *_buffer, int offset);

/*
 * Serialize a Person-message together with its tag into the given buffer 
 * at offset and return new offset for optional next message.
 * Is useful if a Person-message is embedded in another message.
 */
int AccountExchangeNote_write_with_tag(struct AccountExchangeNote *_AccountExchangeNote, void *_buffer, int offset, int tag);

/*
 * Deserialize a Person-message from the given buffer at offset and return
 * new offset for optional next message.
 *
 * Note: All fields in _Person will be reset to 0 before _buffer is interpreted.
 */
int AccountExchangeNote_read_delimited_from(void *_buffer, struct AccountExchangeNote *_AccountExchangeNote, int offset);



#ifdef __cplusplus
  }
#endif

#endif

